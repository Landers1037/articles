---
title: epoll和select
name: linux-epoll-select
date: 2020-03-20
id: 0
tags: [linux]
categories: []
abstract: ""
---


Linux中常见的网络请求处理，select和epoll

<!--more-->

## 请求处理方式

在有请求到达主机时，告诉系统如何处理请求，socket连接该如何保证监听和消息的接收处理

常见的几种方式：select，poll和epoll

**如何从网络接收数据**

通过网卡，网卡会从网络接收数据然后存储到内存中，操作系统可以对接收到达的数据进行操作

三种方法都是阻塞方法，通过cpu中断通知操作系统去处理web请求

### select

操作系统通过分时来处理多任务，假设进程分为两个状态：**运行**和**等待**。当没有web请求时进程进入**等待**状态直到接收到新的消息，一旦接收到数据进程又会变为**运行**状态

假设有一个**工作队列**，队列里是正在运行的进程

有一个**等待队列**，里面是进入等待状态的进程

当有一个进程a创建了一个socket连接，此时没有数据接收。进程a会进入等待队列，这里有一个接收缓冲区，一个发送缓冲区和一个进程列表。进程a就会保存到进程列表里进入**阻塞**状态等待数据到来

当接收到新的数据，产生中断信号，进程a从等待队列出来，进入工作队列进程a被唤醒。

操作系统怎么判断数据是发往那个socket？

怎么同时监听多个socket？

**select的实现**

操作系统监听多个socket，一个进程a用于处理web数据，进程a会进入这多个socket的等待队列。

加入socket1接收到了数据，进程a被唤醒，此时a只需要遍历一遍监听的socket表就可以找到是哪个socket的数据

复杂度分析：调用进程a时遍历一遍监听的socket把a加入它们的等待队列。a唤醒后遍历一遍socket把a从等待队列里去掉。所以有2N的时间复杂度

判断事件是否就绪使用轮询机制

### epoll

epoll相比较select解决了大量的请求时造成的阻塞问题

首先如果想要知道哪个socket接收消息，需要遍历整个socket表。epoll简化了遍历步骤使用系统维护的散列表的方式。所以时间复杂度是O(1)

假设有一个**就绪列表**，当某个socket接收到数据后，就绪列表更新，引用接收数据的socket

就绪列表rdlist里如果存在socket时，epoll_wait会直接返回，当rdlist为空时，epoll_wait执行，此时进程进入阻塞状态，进程被加入到epoll维护的等待队列里等待下次数据的接收

判断时间是否就绪使用的是回调机制

